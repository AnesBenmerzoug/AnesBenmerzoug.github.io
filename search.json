[
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "Posts",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nWhen ECR lifecycle policies are not enough…\n\n\n\n\n\n\n\n\n\n\n\nJul 28, 2020\n\n\nAnes Benmerzoug\n\n\n\n\n\n\n\n\n\n\n\n\nModel Versioning with MLflow\n\n\n\n\n\n\n\n\n\n\n\nJul 8, 2020\n\n\nAnes Benmerzoug\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/when-ecr-lifecycle-policies-are-not-enough/index.html",
    "href": "posts/when-ecr-lifecycle-policies-are-not-enough/index.html",
    "title": "When ECR lifecycle policies are not enough…",
    "section": "",
    "text": "In this second post we will talk about something a bit different from last time. we will be using a tool to extend and take full advantage of ECR Lifecycle Policies to prune more images than is possible with just lifecycle policies.\nWe will be using AWS, a Kubernetes Cluster (self-hosted or EKS), as well as a Continuous Integration system, or CI for short, to build and push images continously to ECR.\nLet’s assume that we are continously building and pushing images to ECR after each push to the master branch. If we just keep doing that we will eventually hit the maximum number of images in a given repository and receive an error message for every subsequent push attempt.\nIn most cases, especially at the beginning of a project, there won’t be a problem because the maximum number of images per repository is quite high (the limit used to be 1000 but was recently increased to 10000).\nFor all other cases it is recommended to use ECR Lifecycle Policies to, at the very least, remove untagged images and prune very old images. But, once we start using them we quickly realize that the allowed rules are quite limited. For example we cannot currently remove all images with a certain tag prefix older than a certain number of days while keeping the last N even if they are too old.\nHere are some examples of rules that cannot be created using them:\nIn this post we will focus on solving the problem from the last example.\nTo do so we could either create our own service/tool to directly prune images and avoid using ECR Lifecycle Policies or we could complement it with a small service/tool that adds a given tag to certain images.\nI went with the later and wrote a small service called kube-ecr-tagger that runs inside the cluster and tags images for us.\nBefore presenting it, let’s have a look into ECR Lifecycle Policies a bit more in detail."
  },
  {
    "objectID": "posts/when-ecr-lifecycle-policies-are-not-enough/index.html#ecr-lifecycle-policies",
    "href": "posts/when-ecr-lifecycle-policies-are-not-enough/index.html#ecr-lifecycle-policies",
    "title": "When ECR lifecycle policies are not enough…",
    "section": "ECR Lifecycle Policies",
    "text": "ECR Lifecycle Policies\nECR lifecycle policies are a part of ECR that enables us to specify the lifecycle management of images in a repository. A lifecycle policy, such as the following, is a set of one or more rules, where each rule defines an action for ECR. The actions apply to images that contain tags prefixed with the given strings. This allows the automation of cleaning up unused images, for example expiring images based on age or count:\n{\n    \"rules\": [\n        {\n            \"rulePriority\": 1,\n            \"description\": \"Expire images older than 14 days\",\n            \"selection\": {\n                \"tagStatus\": \"untagged\",\n                \"countType\": \"sinceImagePushed\",\n                \"countUnit\": \"days\",\n                \"countNumber\": 14\n            },\n            \"action\": {\n                \"type\": \"expire\"\n            }\n        }\n    ]\n}\nThe allowed rules and actions are limited. For example, you cannot do any of the following:\n\nMatch the same image with multiple rules ( this could be used to add exceptions to a rule ). If a rule matches an image it cannot be matched by another rule with a lower priority\nExpire images both by count and by age\nChoose to keep images that match a rule instead of expiring them\nMatch images with an exact tag, only tag prefixes are allowed\n\nTo avoid some of these limitations and to solve our problem from the previous section I developed a simple tool called kube-ecr-tagger."
  },
  {
    "objectID": "posts/when-ecr-lifecycle-policies-are-not-enough/index.html#kube-ecr-tagger",
    "href": "posts/when-ecr-lifecycle-policies-are-not-enough/index.html#kube-ecr-tagger",
    "title": "When ECR lifecycle policies are not enough…",
    "section": "kube-ecr-tagger",
    "text": "kube-ecr-tagger\nkube-ecr-tagger runs inside the cluster and tags the used ECR images in a given namespace, or in all namespaces, with either a given tag or a tag created by appending a unix timestamp to the passed tag prefix.\nIf a tag is passed then there will only be one such tag in each repository. If a tag prefix is passed instead then there will be multiple tags in each repository with the same prefix.\nLet’s use a concrete example. Let’s assume that we use semantic versioning to tag our images in CI and that we are currently at version 1.0.X and that not all images that are pushed will be used in production. Perhaps some of them will fail in the acceptance/staging phase or be flagged for security issues if image scanning is activated.\nWe want to keep the last 100 images that are deployed in production and at the same time remove images whose tag starts with ‘1.0’ and that are older than 30 days. For that we could the following lifecycle policy:\n{\n    \"rules\": [\n        {\n            \"rulePriority\": 10,\n            \"description\": \"Keep last 100 images with tag prefix 'production' \",\n            \"selection\": {\n                \"tagStatus\": \"tagged\",\n                \"tagPrefixList\": [\"production\"],\n                \"countType\": \"imageCountMoreThan\",\n                \"countNumber\": 100\n            },\n            \"action\": { \"type\": \"expire\" }\n        },\n        {\n            \"rulePriority\": 20,\n            \"description\": \"Remove images with tag prefix '1.0' that are older than 30 days\",\n            \"selection\": {\n                \"tagStatus\": \"tagged\",\n                \"tagPrefixList\": [\"1.0\"],\n                \"countType\": \"sinceImagePushed\",\n                \"countNumber\": 30,\n                \"countUnit\": \"days\"\n            },\n            \"action\": { \"type\": \"expire\" }\n        }\n    ]\n}\nThen, in order to tag the images in production, which we assume for the sake of simplicity are deployed in the prod namespace, we will deploy kube-ecr-tagger as a Deployment in the kube-system namespace with the following example manifest:\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n   name: kube-ecr-tagger\n   namespace: kube-system\nspec:\n   template:\n      spec:\n        containers:\n         - name: kube-ecr-tagger\n           image: anesbenmerzoug/kube-ecr-tagger:latest \n           command:\n           - kube-ecr-tagger\n           args:\n           - --namespace=prod\n           - --tag-prefix=production\nWe should not forget to add a service account, if we’re using IAM roles for service accounts, or the right annotation, if we’re using kiam or kube2iam, with the right IAM permissions:\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:GetAuthorizationToken\",\n                \"ecr:BatchCheckLayerAvailability\",\n                \"ecr:GetDownloadUrlForLayer\",\n                \"ecr:DescribeImages\",\n                \"ecr:BatchGetImage\",\n                \"ecr:PutImage\",\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\nExample manifests can be found in the kube-ecr-tagger repository under the manifests folder.\nOnce deployed, it will then check the ECR images of all deployed containers in the prod namespace and add tags with the prefix production to each image, if one does not exist already."
  },
  {
    "objectID": "posts/when-ecr-lifecycle-policies-are-not-enough/index.html#conclusion",
    "href": "posts/when-ecr-lifecycle-policies-are-not-enough/index.html#conclusion",
    "title": "When ECR lifecycle policies are not enough…",
    "section": "Conclusion",
    "text": "Conclusion\nWe have seen in this post that by combining a small tool with ECR Lifecycle Policies we can achieve more complicated rules than with plain lifecycle policies.\nOf course, kube-ecr-tagger is limited in what it can do but one can already have an idea of what can be achieved.\nIf you want to try kube-ecr-tagger you can simply use the built container images from this repository on Dockerhub.\nI hope that you have learned at a thing or two from this post. If there are any mistakes or if you have questions please do not hesitate to reach out to me."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About Me",
    "section": "",
    "text": "I’m a Senior AI Engineer at appliedAI Initiative, Europe’s largest initiative for the application of leading edge trustworthy AI technology with the vision to shape Europe’s innovative power in AI.\nI’m passionate about machine learning, software engineering, and open-source development.\nI am currently working on LLM and NLP use cases with different clients. When I’m not staffed on client projects, I work on internal projects, contribute to open-source projects such as pyDVL and help with TransferLab’s researh projects such as the replication of the If You Like Shapley Then You’ll Love the Core paper.\nI hold a M.Sc. in Embedded Systems from the Technical University of Kaiserslautern and a M.Sc. in Control and Automation from the Ecole Nationale Polytechnique in Algiers."
  },
  {
    "objectID": "index.html#professional-experience",
    "href": "index.html#professional-experience",
    "title": "About Me",
    "section": "Professional Experience",
    "text": "Professional Experience\n\nappliedAI Initiative GmbH / Munich, Germany / July 2023 - Present\n\nSenior Artificial Intelligence Engineer\n\nappliedAI - UnternehmerTUM / Munich, Germany / June 2021 - July 2023\n\nArtificial Intelligence Engineer\n\nAvira / Tettnang, Germany / October 2018 - May 2021\n\nSpecialist Artificial Intelligence Researcher\n\nFraunhofer ITWM / Kaiserslautern, Germany / July 2018 - September 2018\n\nResearch Assistant (HiWi)"
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "About Me",
    "section": "Education",
    "text": "Education\n\nM.Sc. in Embedded Systems / September 2016 - October 2018\n\nTechnical University of Kaiserslautern\n\nM.Sc. in Automation and Control Systems / September 2013 - July 2016\n\nEcole Nationale Polytechnique Algiers"
  },
  {
    "objectID": "index.html#skills",
    "href": "index.html#skills",
    "title": "About Me",
    "section": "Skills",
    "text": "Skills\n\nLanguages\n\nPython\nSQL\nGo\nC#\n\n\n\nAI\n\nMachine Learning\nDeep Learning\nLarge Language Models (LLMs)\nRetrieval Augmented Generation (RAG)\nData Valuation\nExplainability (XAI)\n\n\n\nTechnologies\n\nDocker\nKubernetes\nPostgreSQL\nFastAPI\nAWS, Azure"
  },
  {
    "objectID": "posts/model-versioning-with-mlflow/index.html",
    "href": "posts/model-versioning-with-mlflow/index.html",
    "title": "Model Versioning with MLflow",
    "section": "",
    "text": "In this very first post we will talk about machine learning model versioning and more specifically machine learning classifier versioning.\nOf course, one could simply compare accuracies ( or whichever metric you’re using ) on a separate test set and promote whichever classifier has a better value but that does not offer us the same guarantees as statistical tests.\nFor example, one may train two different classifiers on the same dataset and get the following results on a separate test set:\nWe can see that the first classifier has an accuracy of 60% and the second classifier an accuracy of 50%. If we were to stop here we would just say that the first classifier is better than the second one and that could be true, but can this result be trusted?\nTo verify that we construct the following confusion matrix:\nBy comparing the off-diagonal elements, we can intuitively know that there isn’t much of a difference between the two classifiers. To make that more precise we can use statistical tests instead of just comparing numbers.\nOne such test is McNemar’s Test.\nBefore explaining McNemar’s Test and the different steps used to compare two machine learning classifiers, let’s first talk about MLflow."
  },
  {
    "objectID": "posts/model-versioning-with-mlflow/index.html#mlflow",
    "href": "posts/model-versioning-with-mlflow/index.html#mlflow",
    "title": "Model Versioning with MLflow",
    "section": "MLFlow",
    "text": "MLFlow\nMLflow is an open source platform for the machine learning life-cycle. It is currently composed of four components:\n\nMLflow Tracking: Used to record and query experiments: code, data, config, and results\nMLflow Projects: Used to package data science code in a format to reproduce runs on any platform\nMLflow Models: Used to deploy machine learning models in diverse serving environments\nMLflow Model Registry: Used to store, annotate, discover, and manage models in a central repository\n\nIt uses a classic client server architecture as depicted in the following diagram:\n\n\n\n\n\nflowchart TD\n    subgraph MLflow\n        database[(Database)] &lt;--&gt; server(Server)\n        storage[(Storage)] &lt;--&gt; server\n    end\n\n    server &lt;--&gt; client(Client)\n\n\n\n\n\n\nThe Client, user, interacts directly with the Server and the Server in turn interacts with the Database (MySQL, MSSQL, SQLITE, or POSTGRESQL) and the Storage backend (Local or Cloud).\nIn this post we’re only interested in the last component: the Model Registry.\nIt is a centralized model store, set of APIs, and UI, to collaboratively manage the full life-cycle of an MLflow Model. It provides model lineage (which MLflow experiment and run produced the model), model versioning, stage transitions (such as from staging to production), and annotations.\nA registered model can be in any one of the following stages: - None - Staging - Production - Archived\nAs can be seen in the following flowchart, a model starts, when first logged or registered, in the None stage and then transitions to the Staging stage, then to the Production stage and finally end its life-cycle in the Archived stage.\n\n\n\n\n\nflowchart LR\n    none(None)\n    staging(Staging)\n    production(Production)\n    archived(Archived)\n\n    none --&gt; staging\n    staging --&gt; production\n    production --&gt; archived\n\n\n\n\n\n\nFor simplicity’s sake we won’t consider other possible transitions (e.g. Staging -&gt; Archived).\nWhat the Model Registry does not take care of is automatically transition a given model to the appropriate stage and that is understandable because the conditions needed to do that depend on the actual application."
  },
  {
    "objectID": "posts/model-versioning-with-mlflow/index.html#mcnemars-test",
    "href": "posts/model-versioning-with-mlflow/index.html#mcnemars-test",
    "title": "Model Versioning with MLflow",
    "section": "McNemar’s test",
    "text": "McNemar’s test\nMcNemar’s test is a non-parametric statistical test that can be used to compare two classification models by constructing a 2x2 contingency table, or confusion matrix, like the following:\n\n\n\n\nModel 2 Correct\nModel 2 Wrong\n\n\n\n\nModel 1 Correct\na\nb\n\n\nModel 1 Wrong\nc\nd\n\n\n\nIn order to test if there is a significant difference between the two models, we use only the off-diagonal elements, b and c, since the other elements tell us nothing about whether one model is better than the other or not.\nMcNemar’s test statistic is:\n\\[\nQ = \\frac{(b - c)}{b + c}\n\\]\nWhich, for large values of b and c, follows a chi-squared distribution with 1 degree of freedom \\(\\chi_{1}^{2}\\).\nTo more closely approximate the chi-squared distribution we can use the following definition instead which contains a continuity correction:\n\\[\nQ = \\frac{(|b - c| - 1)}{b + c}\n\\]\nIf the result is significant, i.e. greater than a pre-defined significance level, usually set to 0.05 but can be changed depending on the use case, then we can conclude that the two models are significantly different from each other.\nBut it does not end there, we still have to determine which one of the two is better than the other one. For that, we can use one or a combination of the usual metrics: Accuracy, F-Score, False Positive Rate, etc.\nIf we apply the continuity corrected version of the test on our previous example we get as result 1.0 and can confidently say that there is no significant difference between the two classifiers."
  },
  {
    "objectID": "posts/model-versioning-with-mlflow/index.html#model-versioning-flow",
    "href": "posts/model-versioning-with-mlflow/index.html#model-versioning-flow",
    "title": "Model Versioning with MLflow",
    "section": "Model Versioning Flow",
    "text": "Model Versioning Flow\nNow that we have defined and explained all the required parts of the flow. We can assemble them into the following chart that shows the different steps taken to compare two different classification models:\n\n\n\n\n\ngraph TD\n    End--&gt;title[\"Model Versioning Flow Chart\"]\n    style title fill:#FFF,stroke:#FFF\n    linkStyle 0 stroke:#FFF,stroke-width:0;\n    Start((Start)) --&gt; A\n    A(McNemar's Test) --&gt; B{\"P-value &lt; &alpha;\"}\n    B --&gt;|No| End((End))\n    B --&gt;|Yes| C(Compute&lt;br&gt;Accuracies)\n    C --&gt; D{Model1 Accuracy&lt;br&gt;&lt;&lt;br&gt;Model2 Accuracy}\n    D --&gt;|No| End\n    D --&gt;|Yes| E(Deploy Model2)\n    E --&gt; End\n\n\n\n\n\n\nHere we use accuracy, but it could be replaced by other metrics such as False Positive Rate, False Negative Rate, etc."
  },
  {
    "objectID": "posts/model-versioning-with-mlflow/index.html#example",
    "href": "posts/model-versioning-with-mlflow/index.html#example",
    "title": "Model Versioning with MLflow",
    "section": "Example",
    "text": "Example\nIn this repository you can find example code in Python that shows how to use the previous flow to do model versioning for machine learning classifiers with MLflow.\nOne important thing that should always be done is to pin the random seed to ensure the experiment’s repeatability.\nrandom_seed = 16\nnp.random.seed(random_seed)\nIn the example, we start off by generating artificial classification data using scikit-learn’s make_classification helper function and then splitting it into a training and a testing set:\nX, y = make_classification(\n        n_samples=10000,\n        n_classes=2,\n        n_features=20,\n        n_informative=9,\n        random_state=random_seed,\n)\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, train_size=0.8, test_size=0.2\n)\nAfter that, we fit a Logistic Regression classifier, then register and log it into MLflow and finally move it to the Production phase:\nwith mlflow.start_run():\n    lr_model = LogisticRegression()\n    lr_model.fit(X_train, y_train)\n    y_pred = lr_model.predict(X_test)\n    accuracy = accuracy_score(y_test, y_pred)\n    mlflow.log_metric(\"accuracy\", accuracy)\n    mlflow.sklearn.log_model(\n        lr_model, artifact_path=\"model\", registered_model_name=\"Logistic Regression\"\n    )\n\nmlflow_client.transition_model_version_stage(\n    name=\"Logistic Regression\", version=1, stage=\"Production\"\n)\nThen, we fit a Random Forest classifier, then register and log it into MLflow and finally move it to the Staging phase:\nwith mlflow.start_run():\n    rf_model = RandomForestClassifier()\n    rf_model.fit(X_train, y_train)\n    y_pred = rf_model.predict(X_test)\n    accuracy = accuracy_score(y_test, y_pred)\n    mlflow.log_metric(\"accuracy\", accuracy)\n    mlflow.sklearn.log_model(\n        rf_model, artifact_path=\"model\", registered_model_name=\"Random Forest\"\n    )\n\nmlflow_client.transition_model_version_stage(\n    name=\"Random Forest\", version=1, stage=\"Staging\"\n)\nTo simulate the fact that the model comparison may happen in another script we delete both trained model instances and load them back from MLflow:\ndel lr_model\ndel rf_model\n\nlr_model_download_uri = mlflow_client.get_model_version_download_uri(\n    name=\"Logistic Regression\", version=1,\n)\nrf_model_download_uri = mlflow_client.get_model_version_download_uri(\n    name=\"Random Forest\", version=1,\n)\nlr_model = mlflow.sklearn.load_model(lr_model_download_uri)\nrf_model = mlflow.sklearn.load_model(rf_model_download_uri)\nAs a next step, we use both models to generate predictions on the test set. We use these predictions to compute each model’s accuracy and to create a contingency table that is finally used in a corrected version of McNemar’s Test to return a P-value:\ny_pred_lr = lr_model.predict(X_test)\ny_pred_rf = rf_model.predict(X_test)\n\naccuracy_lr = accuracy_score(y_test, y_pred_lr)\naccuracy_rf = accuracy_score(y_test, y_pred_rf)\n\ncontingency_table = mcnemar_table(y_test, y_pred_lr, y_pred_rf)\n_, p_value = mcnemar(contingency_table, corrected=True)\nFinally we use the obtained P-value and the accuracies to decide whether we should deploy the Random Forest classifier to Production and archive the Logistic Regression classifier or not:\nif p_value &lt; significance and accuracy_lr &lt; accuracy_rf:\n    mlflow_client.transition_model_version_stage(\n        name=\"Logistic Regression\", version=1, stage=\"Archived\",\n    )\n    mlflow_client.transition_model_version_stage(\n        name=\"Random Forest\", version=1, stage=\"Production\",\n    )\nWe can then access the MLflow server’s dashboard and see that the Random Forest classifier’s version 1 is in Production and the Logistic Regression classifier’s version 1 was archived:\n\n\n\n\nMLflow Model Versioning Screenshot\n\n\n\nAll that’s left now is to run this or similar code either on a schedule or as part of a training workflow each time a new classifier is trained and logged."
  },
  {
    "objectID": "posts/model-versioning-with-mlflow/index.html#conclusion",
    "href": "posts/model-versioning-with-mlflow/index.html#conclusion",
    "title": "Model Versioning with MLflow",
    "section": "Conclusion",
    "text": "Conclusion\nWe have seen that thanks to the Model Registry component of MLflow we can have a pretty simple automated model versioning flow for classifiers. This flow can be and should be extended and made more complete, depending on the use case. For example, by using a second metric for when a tie happens in the first one.\nI hope that you have learned at a thing or two from this post. If there are any mistakes or if you have questions please do not hesitate to reach out to me."
  }
]
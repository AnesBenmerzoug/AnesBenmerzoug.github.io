---
title: Python and Poetry
date: 2024-10-21
keywords: [
    "Python",
    "Python 3.13",
    "GIL",
    "free threading",
    "Poetry",
    "Benchmark",
]
license: "CC BY"
draft: true
---

After a long pause of more than 4 years, I have finally
decided to come back to my personal blog and start writing again.

For this first post in a long while, I wanted to do something simple: benchmark the performance of [poetry](https://python-poetry.org/) the python package manager when using different python versions. I use poetry on a daily basis either for work or for personal projects and I wondered weather Poetry's performance changes significantly based on which python version it uses.

The idea came to me after I saw that Python 3.13 was released with experimental [free threading](https://docs.python.org/3/howto/free-threading-python.html) support where the [global interpreter lock (GIL)](https://docs.python.org/3/glossary.html#term-global-interpreter-lock) is disabled. I 
To test that, I decided to take inspiration from the [python-package-manager-shootout](https://github.com/lincolnloop/python-package-manager-shootout) repository which benchmarks different package manager using a fixed python version.

> Unfortunately, as of writing this blog post poetry can't installed directly from PyPI using Pyhton 3.13 with the GIL disabled due to an issue with some of its dependencies, namely: msgpack and cryptography once that's resolved I will try to update this post or write another one.

The remainder of this post is structured as follows:

- we will briefly see how to install the new python version with free threading enabled,
- then, we will describe the different operations as well as the setup that will used in the benchmarks
- finally, we will visually analyze the result of the benchmarks. 

# Installation

We will now see how to install python 3.13 version with and without free threading using [pyenv](https://github.com/pyenv/pyenv).

Let's first start by listing all available python versions for installation:

```shell
pyenv install -l
```

The result should look something like:

```shell
Available versions:
  2.1.3
  2.2.3
  2.3.7
  ...
  ...
  3.13.0
  3.13.0t
  ...
  ...
```

If you don't see python 3.13 listed, it probably
means that you need to update pyenv to the latest version using:

```shell
pyenv update
```

To install Python 3.13 with free threading disabled (i.e. GIL enabled), you would use:

```shell
pyenv install 3.13.0
```

To install Python 3.13 with free threading enabled (e.g. GIL disabled), you would use:

```shell
pyenv install 3.13.0t
```

To test whether this worked, you would use:

```shell
python -VV
```

The output should contain "experimental free-threading build" for the latter and not for the former.

For more detailed instructions and explanations, please refer to [this blog post](https://realpython.com/python313-free-threading-jit/)
from [realpython.com](https://realpython.com)

# Benchmarks

To test that, we will compare using the latest version of Poetry (version 1.8.4 as of writing this blog post)
with a few different Python versions: 3.11, 3.12 and 3.13

All the files related to this blog post can be found in 
[this repository](https://github.com/AnesBenmerzoug/poetry-python-benchmark). It is heavily inspired by the [python-package-manager-shootout](https://github.com/lincolnloop/python-package-manager-shootout) repository.

Similarly to that repository, we use a list of packages from a fixed version of [Sentry's `requirements.txt file`](https://github.com/getsentry/sentry/blob/da11f63098ef5c661e879effb8688178bb5eccee/requirements-base.txt) which was chosen arbitrarily as a non-trivial real-world example.

Unlike in [python-package-manager-shootout](https://lincolnloop.github.io/python-package-manager-shootout/),
we use a newer version of Sentry's requirements to avoid any issues during package installation with newer Python versions. Additionally, we use [hyperfine](https://github.com/sharkdp/hyperfine) to handle the execution and timing of each operation.

The benchmarked operations are the following:

- `import`: For this operation, we call `poetry add --lock --no-cache` to import all of the requirements in Sentry's requirements.txt file into a newly initialized pyproject.toml file (We use Poetry's `--lock` flag to prevent it from installing packages at this point).
- `lock`: For this operation, we call `poetry lock` both with and without the `--no-cache`
- `install`: For this operation, we call `poetry install` both with and without the `--no-cache`
- `update`: For this operation, we call `poetry update` both with and without the `--no-cache`
- `add package`: For this operation, we call `poetry add numpy --no-cache`


> The `--no-cache` flag is used to tell poetry

# Results

> The results can be found as artifacts of the the repository's [CI workflows](https://github.com/AnesBenmerzoug/poetry-python-benchmark/actions). The results used in this post come from [this specific workflow](https://github.com/AnesBenmerzoug/poetry-python-benchmark/actions).

![Benchmark result of poetry import operation](barplot_import.png){#fig-import .lightbox}

![Benchmark result of poetry lock operation](barplot_lock.png){#fig-import .lightbox}

![Benchmark result of poetry install operation](barplot_install.png){#fig-import .lightbox}

![Benchmark result of poetry update operation](barplot_update.png){#fig-import .lightbox}

![Benchmark result of poetry add package operation](barplot_add.png){#fig-import .lightbox}

As we can see form the results, python 3.13 without free threading doesn't improve poetry's performance but rather deteriorates in many of the cases.

It remains to be seen whether the experiemtal free threading and/or JIT features would make a change.
